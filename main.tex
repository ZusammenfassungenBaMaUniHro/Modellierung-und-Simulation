\documentclass[11pt, fleqn, a4paper, leqno]{scrartcl} %A4
\usepackage[utf8x]{inputenc} %Eingabe
\usepackage[T1]{fontenc} %Font

\usepackage[ngerman]{babel} %Trennnung
\usepackage{amsmath} %Mathesysmbole
\usepackage{graphicx} %Grafiken
\usepackage{listings} %Programmcode
\usepackage{tikz} %Grafiken malen
\usetikzlibrary{arrows}

\usepackage{hyperref}
\usepackage{dsfont}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...,mean,avg,clone},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=1,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}



\title{Zusammenfassung: Modellierung und Simulation}
\author{Andreas Ruscheinski}
\date{}
\begin{document}
\maketitle
\tableofcontents
% Verhindert Hurenkinder
\widowpenalty = 10000
% Verhindert Schusterjungen
\clubpenalty = 10000

\section{Hinweis}
Die Urheberrechte der Bilder liegen bei Prof. Adelinde Urmacher, entstammen der Vorlesung "Modellierung und Simulation" aus dem Sommer Semester 2014. Die Texte sind an die Vorlesung angelehnt und entsprechen teilweise dieser. In diesem Fall liegen die Urheberrechte ebenfalls bei Prof. Adelinde Urmacher. Die Autoren übernehmen keine Garantie für Richtigkeit und Vollständigkeit.
\section{Einführung}
	\subsection{Vorbetrachtung}
	\begin{itemize}
		\item Experimente mit dem Computer als Labor
		\item Beispiele: Maschinenanordnung in einer Firma optimieren, Flugzeug fliegen lernen 
		\item Warum: Reale Experimente nicht oder nur teilweise durchführbar (Menschenexperimente, Klimaveränderungen, Entwicklung über mehrere Jahrhunderte)
		\item Risiken: falsche Ergebnisse (Modell passt nicht immer in die Reale Welt, Benutzer obliegt die Verantwortung die Ergebnisse zu interpretieren und kritisch zu hinterfragen)
	\end{itemize}
	\subsection{Definitionen}
	\begin{description}
		\item[System:] Ein System besteht aus Eingaben, Ausgaben und dem Verhalten. Man unterscheidet in Umgebung eines Systems und das Innere eines Systems. Die Umgebung gilt als Abgrenzung. Das Innere beschreibt die Zustände, Komponenten und die Relationen der einzelnen Komponenten. Es muss für jedes System die Systemelemente, Kommunikationsstrukturen und der Veränderung von Werten über die Zeit identifiziert werden.
		\item[Modell:] Ein Modell ist eine Abstraktion eines Systems. Wir stellen ein Modell nur zusammen mit einem System und einem Experiment da. \glqq A model (M) for a system (S) and an experiment (E) is anything to which E can be applied to answer questions about (S).\grqq
		\item[Experiment:] Ein Experiment beinhaltet eine klare Fragestellung (Was soll beantwortet werden?). An ein Experiment sind verschiedene Kriterien gestellt z.b Wiederholbarkeit(unter identischen Voraussetzungen sollen identische Experimente zu den identischen Ergebnissen führen). Wichtig ist dabei die Dokumentation des Experimenten indem die Voraussetzungen, Umgebungsparameter und die Ergebnisse fest gehalten werden. \glqq An experiment is the process of extracting data from a system by excerting it through its input.\grqq
		\item[Simulation:] Eine Simulation ist ein Experiment welches auf einem Modell ausgeführt wird. 
		\item[Computer Modell:] Ein durch einen Computer ausführbares Modell, d.h. definiert in einer durch den Computer interpretierbaren Syntax.
		\item[Computersimulation:] Ein durch einen Computer ausführbares Experiment mit einem computerbasierten Modell.
	\end{description}
\section{Modellierung, Modelle und Sichten}
	\subsection{Wie kommt man von einem System zum Modell?}
		Man unterscheidet dabei zwei grundlegende Vorgehensweisen: induktiv und deduktiv. Bei der induktiven Modellbildung wird das Modell ausgehen von Experimente und Beobachten realer Systeme unter Auswertung der Daten gewonnen. Bei der deduktiven Modellbildung wird das Modell ausgehen von Hypothesen, Lehrmeinungen, Gesetze und Prinzipien gewonnen. Modellierung ist also der Prozess das Wissen über ein System anzuordnen. Es werden die gebildeten Modelle noch weiter unterschieden in Gedankenmodelle (ausgedacht), Verbalmodelle (Modelle auf Basis von Texten und Gesprächen bzw. Beschreibungen) und Formal Modelle (Formale Spezifikation des Modelles durch Logik o.ä). Diese Modelle lassen sich noch weiter in 2 große Bereiche unterteilen, Realmodelle (Welche ausgehend von der Realität gebildet werden) und Ikonische Modelle (dienen zur Veranschaulichung von Sachverhalten, erklären diesen jedoch nicht).
	\subsection{Modellentwicklung}
		Die Modellentwicklung wird unter Berücksichtigung von verschieden Fragen durch geführt. Typische Fragen dabei sind: Was sind wichtige Variablen und wie ist deren Beziehung?, Wie sind die Variablen skaliert?, Ist die Dynamik eher kontinuierlich oder diskret?, Welche Rolle spielt Stochastik?, Was ist interessant? Was sind die Elemente eines Systems?. Man unterscheidet dabei die Variablen in qualitativ skalierte Variablen (incl. Constraints) und quantitative Variablen. Qualitative Variablen haben nur eine begrenze Anzahl an Merkmalsausprägungen (Geschlecht, Religion) wobei quantitative Variablen angeben wie viel, wo von existiert.
	\subsection{Sichten auf Systeme}
	\begin{description}
		\item[Warteschlagenmodelle:]Die Vorstellung des Modells beruht auf die Abarbeitung einer Folge von Aufträgen durch n Bedieneinheiten, wobei die Verteilung der Aufträge und Bearbeitungsdauern variieren können. Beispiele: die immer vollen Warteschlangen in der Mensa, am Flughafen oder im Kaufland und warum muss ich trotz Termin beim Arzt immer warten?
		\item[Makromodelle:] Die Vorstellung des Modells beruht auf die Betrachtung der angenommenen Werte der Variablen. Beispiel: Entwicklung der Bevölkerung
		\item[Mikromodelle:] Die Vorstellung des Modells beruht auf eine differenzierte Betrachtung der Entitäten. Beispiel: Eine Menge von Haushalten, und ihr Einkommen
		\item[Agentenmodelle:] Die Vorstellung des Modells beruht, ähnlich den Mikromodellen, auf einer differenzierten Betrachtung wobei jedoch jedes Element sich über die Laufzeit verändern kann und dabei miteinander kommunizieren. Beispiel: Überlebenssimulation auf einer Insel mit verschiedenen Überlebenden.
		\item[Räumliche Modelle:] Die Vorstellung des Modells beruht darauf das alle Entitäten einen Ort haben und sich ggf. Bewegen. Beispiel: Geosimulation, Moleküle
		\item[Mehrebenenmodelle:] Die Vorstellung des Modells beruht darauf das mehrere Organisationsebenen miteinander verbunden sind und jede Ebene eigene Eigenschaften und Verhaltensmuster aufweisen. Beispiel: Simulation des Menschlichen Organismus (Moleküle, Zellen, Zellverbände, Organe, Organismus)
		\item[Mehrskalenmodelle:]  Die Vorstellung des Modells beruht darauf das sich die Elemente verändern, wobei jedoch die Veränderungen weit auseinander liegen. Im allgemeinen stehen räumliche und zeitliche Skalen in Verbindung. Beispiel: Simulation der Plattentektonik
		\item[Strukturdynamische Modelle:] Die Vorstellung des Modells beruht darauf das die Elemente ihr Interaktionsmuster und ggf. ihre Schnittstellen verändern. Beispiel: Simulation einer Serverfarm, Was passiert wenn 2 Server ausfallen?
		\item[Veränderungen:] Die Veränderung der Eigenschaften kann dabei empirisch Ermittelt worden sein, durch eine Formel abgebildet oder durch Wahrscheinlichkeiten modelliert werden.
	\end{description}
	\subsection{Zeitbasen}
		\subsubsection{Grundlegende Zeit Definition}
			\begin{description}
				\item[Physikalische Zeit:] die Zeit die im modellierten System verstreicht z.B die erste Sekunde nach dem Urknall
				\item[Simulationszeit:] die modellierte physikalische Zeit die während einer Berechnung verstreicht (Eigene Interpretation: quasi die Auflösung für einzelne Schritte, ein Schritt berechnet 1ms oder 1ns)
				\item[Wanduhrzeit:] die Zeit die in der realen Welt währed der Berechnung verstreicht (Die Simulation brauch 30d.q)
			\end{description}
		\subsubsection{Wie wird die Zeit in Modellen dargestellt?}
			\begin{description}
				\item[kontinuierlich:] Fließkommazahlen im Rechner, beliebig feine Auflösung
				\item[diskret:] Ganzzahlen im Rechner, Auflösung fest
			\end{description}
		\subsubsection{Kontinuierliche Modelle}
			\begin{description}
				\item[Beschreibung:] Unendlich viele Zustandsübergänge im Zeitintervall, Beschreibung meistens durch Differentialgleichungen, z.B: Wasser fliest kontinuierlich in Badewanne
				\item[Zeit:] $\mathds{R}$
				\item[Zustandsraum:] $\mathds{R}^{n}$
				\item[Input/Output:] $\mathds{R}^{n}$
			\end{description}
			\begin{center}
				\includegraphics [scale=0.6]{images/kontinuierliche-modelle.jpg}
			\end{center}
		\subsubsection{Diskrete Modelle - schrittweise}
			\begin{description}
				\item[Beschreibung:] Endlich viele Zustandsübergänge pro Zeitintervall, Konstante Intervallänge (Alle Modellteile im Gleichtakt), Zustand bleibt bis zum nächsten Takt konstant, Beispiel: Wir füllen Badewanne in regelmäßigen Abständen mit Wassereimern
				\item[Zeit:]$\mathds{N}$
				\item[Zustandsraum:] beliebig
				\item[Input/Output:] beliebig
			\end{description}
			\begin{center}
				\includegraphics [scale=0.6]{images/diskret-schrittweise.jpg}
			\end{center}
		\subsubsection{Diskrete Modelle - Ereignisse}
			\begin{description}
				\item[Beschreibung:] Endlich viele Zustandsübergänge pro Zeitintervall, Modelle entwicklen sich durch Ereignisse, Zustand bleibt bis zum nächsten Ereigniss konstant, Beispiel: Wir füllen Badewanne immer wenn wir angerufen werden mit Wassereimern
				\item[Zeit:] $\mathds{R}$
				\item[Zustandsraum:] beliebig
				\item[Input/Output:] beliebig
			\end{description}
			\begin{center}
				\includegraphics [scale=0.6]{images/diskret-ereignisse.jpg}
			\end{center}
		\subsubsection{Hybride Modelle}
			\begin{description}
				\item[Beschreibung:] Kombination aus kontinuierlichen und diskreten Modellen, es gibt sowohl Ereignisse welche durch die Zeit oder durch das Eintreten bestimmter Sitationen. Beispiel: Wir lassen Badewanne normal vollaufen und kippen alle 5 Minuten einen Wassereimer hinzu und immer dann wenn wir angerufen werden.
			\end{description}
			\begin{center}
				\includegraphics [scale=0.6]{images/hybrid.jpg}
			\end{center}
	\subsection{VVA von Modellen}
		\begin{description}
			\item[Verifikation:] Korrekte Transformation oder Beweisen
			\item[Validierung:] Korrektes Modell oder Testen
			\item[Akkreditierung:] Dritte Partei die das Modell (VV) betätigt
		\end{description}
\section{Zelluläre Automaten}
	\subsection{Endliche Automaten}
		Die Formale Definition: $M=(Q,\Sigma,\Delta,\beta,q_{0},\Lambda)$ mit:
		\begin{itemize}
			\item Q endliche Menge an Zuständen
			\item $\Sigma$ endlichen Eingabealphabet
			\item $\Delta$ Ausgabealphabet
			\item $\beta$ Zustandübergangsfunktion: $\beta: Q \times \Sigma \rightarrow Q, \beta(p,a) = q$, mit $p,q \in Q, a\in \Sigma$
			\item $q_{0}$ Startzustand
			\item $\Lambda$ Ausgabefunktion
		\end{itemize}
		\begin{description}
			\item[Mealy-Automaten:] Ausgabe nur Abhängig von der Eingabe ab. 
				\begin{itemize}
					\item $\Lambda: Q \times \Sigma \rightarrow \Delta$
					\item $\Lambda(p,a) = b$ mit $p\in Q, a \in \Sigma$, $ b\in \Delta$
				\end{itemize}
			\item[Moore-Automaten:] Ausgabe nur Abhängig von dem Zustand ab
				\begin{itemize}
					\item $\Lambda: Q \rightarrow \Delta$
					\item $\Lambda(p) = b$ mit $p\in Q$, $b\in \Delta$					
				\end{itemize}
		\end{description}
	\subsection{Defintion: zelluärer Automat}
		Die Idee von zellulären Automaten besteht darin mehere Automaten zu koppeln. Die Art der Koppelung bezeichnet man auch als Nachbarschaft. Anstelle von expliziten Eingaben, ändert sich der Zustand eines Automaten in Abhängigkeit von dessen Nachbarn. Nachfolgend die formale Definition eines zellulären Automaten: $CA=(L,N,S,G,G_{init},R)$ mit:
		\begin{itemize}
			\item $L$ dem Zellraum, $L \subset \mathds{R}^{d}$ wobei d: d-dimensionaler Raum, somit ist L die Menge der homogen (gleichmaßig) über dem Raum verteilter Zellen. Jede Zelle wird durch ihre Position $r\in L$ bezeichnet.
			\item $N(r) := \{r+c_{i}:c_{i} \in \mathbf{N}_{diff(b)}, i = 1,\dots,b\}$ mit $\mathbf{N}_{diff(b)}$ der Offset, der die Nachbarn bestimmt, b ist die Anzahl der nächsten Nachbarn im Raum (2 für dimensional, 3 für Dreiecke usw \dots).
			\item $S$ der endliche Zustandsraum  mit $\forall r \in L : s(r) \in S (s : L \rightarrow S)$
			\item G der Zustand des zellulären Automaten, $G \in S^{|L|}$,$G := (s(r_{1}),\dots,s(r_{|L|})) = (s(r_{_{i}})_{r_{_{i}}} \in L)$
			\item $G_{init}$ der initiale Zustand des zellulären Automaten, $G_{init} \in S^{|L|}$
			\item $R$ die Zustandsüberführungsfunktion
		\end{itemize}
		Die Definition scheint jetzt sehr komplex. Wir werden diese jedoch später in einem Beispiel erläutern. Die Wahl der Nachbarschaft ist frei wählbar, es gibt jedoch zwei typische Nachbarschaften.\\
		\begin{enumerate}
		\item von-Neumann-Nachbarschaft: Nachbarn welche mit einer \glqq langen\grqq\ Seite an die Zelle.
		\item Moore-Nachbarschaft: alle benachbarten Zellen (alle Zellen welche eine Zelle berühren)
		\end{enumerate}
		Die Ränder des Automaten können verschieden behandelt werden. Entweder der Automat endet d.h. die Anzahl der Nachbarn an der Randzellen ist kleiner und die gedachten außerhalb liegenden Zellen haben einen festen Zustand oder die Welt ist ein Torus d.h. der Nachbar der Zelle am Rand ist auf der gegenüberliegenden Seite.\\
		Bisher wurde nicht geklärt wie wir die Schritte des Automaten berechnen. Mögliche Strategien wären:
		\begin{itemize}
			\item pro Schritt wird nur eine Zelle berechnet, Problem: Reihenfolge der Zellen
			\item alle Zellen pro Schritt berechnet und diese arbeiten auf den aktuellen Zustand der Nachbarn
			\item alle Zellen pro Schritt aber mit dem Zustand der Nachbarn aus dem vorigen Schritt
		\end{itemize}
	\subsubsection{Beispiel}
		Nachfolgend einige Beispiele für zelluläre Automaten.\\
		Beispiel 1: 1-dimensionale zelluläre Automaten\\
		$CA = (L,N,S,G,R)$ mit:
		\begin{itemize}
			\item $L \subseteq \mathds{Z}$(der Zellraum ist ein Band)
			\item $N_{diff(b)} = \{1,-1\}$(der linke und der rechte Nachbar)
			\item $S =$\{dead,alive\}(Zellen sind tot oder lebendig)
			\item  $G_{init} = \{s(r_{1},\dots,s(r_{ |l|}))\}\setminus \frac{|L|}{2}:s(r_{i})=$dead und $s(r_{\frac{|L|}{2}})=$ alive (alle Zellen sind tot ausser die Zelle mit dem Index $\frac{|L|}{2}$ sind tot)
			\item $R=$ die verwendete Regel.
		\end{itemize}
		Nachfolgend wird das Prinzip der Regel eingeführt. Nehmen wir an wir wählen eine Zelle auf dem Band mit dem Index $i$. Der Zustand dieser Zelle kann nach der obigen Definition nur von den beiden Nachbarzellen abhängen, da  $N(r) := \{r+c_{i}:c_{i} \in \mathbf{N}_{diff(b)}, i = 1,2\}$ mit $N_{diff(b)} = \{1,-1\}$ folgt $N(i)=\{i-1,i+1\}$, und von sich den eignen Zustand. Somit interessieren uns alle verschiedenen Anordnungen von $i-1,i,i+1$ mit den Belegungen $S={0,1}$ (0 nachfolgend für dead, 1 nachfolgend für alive). So ergeben sich 8 verschiedene Anordnungen. Für jede Anordnung müssen wir angeben wie sich die mittlere Zelle i entwickelt. Dieses geschieht über die Angabe der Regel in Binärcodierung. Nachfolgend ein Beispiel für Regel 42. \\
		Als erstes stellen wir $[42]_{10}$ als binär da. $42= 0*2^{7}+0*2^{6}+1*2^{5}+0*2^{4}+1*2^{3}+0*2^{2}+1*2^{1}+0*2^{0}=0*128+0*64+1*32+0*16+1*8+0*4+1*2+0*1=[00101010]_{2}$ und tragen das Ergebnis in die Tabelle ein.
		\begin{center}
			\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
			\hline Muster & 111 & 110 & 101 & 100 & 011 & 010 & 001 & 000 \\ 
			\hline Neuer Zustand von i & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0    \\ 
			\hline 
			\end{tabular} 
		\end{center}
		Nachfolgend die Entwicklung des Automaten mit der Länge 5 über 2 Generationen mit der Annahme das die Zellen außerhalb des Randes den Wert 0 haben. In der Startkonfiguration haben alle Zellen haben den Wert 1.
		\begin{center}
			\begin{tabular}{|c||c|c|c|c|c||c|}
			\hline 0 & 1 & 1 & 1 & 1 & 1 & 0 \\ 
			\hline 0 & 1 & 0 &  0& 0 & 0 & 0 \\ 
			\hline 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 
			\hline 
			\end{tabular} 
		\end{center}
		Für mehre Dimensionen funktioniert dies Analog. Siehe Vorlesungsfolien.
		\newpage
\section{Discrete Event System Specification (DEVS)}
	\subsection{Vergleich zu zellulären Automaten}
		Im Vergleich zu zellulären Automaten ist in DEVS die Positionierung der einzelnen Bausteine egal und die Kommunikation kann mit belieben Komponenten erfolgen, nicht wie bei den CA mit den unmittelbar anliegenden Nachbarn. Mit DEVS ist es möglich ein System sowohl durch Dekomposition einzelne Bausteine zu verfeinern als auch durch Komposition die Bausteine wieder zusammen zu fassen. Dadurch ist es möglich in DEVS ein System beliebig fein/grob zu spezifizieren. Der Formalismus ist diskret Ereignisorientiert d.h. wir springen von Ereignis zu Ereignis.
	\subsection{Atomare Modelle}
		Ein atomares Modell besitzt einen Zustand in diesem das System über einen definierten Zeitraum (auch unendlich lange) verweilt. Der Zustand ändert sich erst wenn ein Ereignis eintritt oder die Verweilzeit abgelaufen ist. Zu dem Ereignis gehört die aktuelle Zeit. Die Kombination von Zustand, Ereignis und der aktuellen Zeit entscheidet in welchem neuen Zustand das System übergeht. Die Zustandsüberführung kann durch ein externes Ereignis(direkte Eingabe) oder ein internes Ereignis(Verweilzeit) ausgelöst werden. Ausgehend durch diese Betrachtung ergibt sich folgende formale Spezifikation: $DEVS = (X,Y,S,\beta_{int},\beta{ext},ta,\lambda)$ mit: 
		\begin{itemize}
			\item $X$ die Eingabemenge
			\item $Y$ die Ausgabemenge
			\item $S$ die Menge der Zustände
			\item $ta: S \rightarrow \mathds{R}^{+}_{0,\infty}$ Zeitfortschrittfunktion weist jedem Zustand eine Zeitspanne zu, in die dieser Zustand von sich aus bestehen bleibt bevor ein interner Zustandsübergang ausgelöst wird
			\item $\beta_{int}: S \rightarrow S$ interne Übergangsfunktion (zeitgetriggerte Ereignisse)
			\item $\beta_{ext}: Q \times X \rightarrow S$ externe Übergangsfunktion (situative Ereignisse) mit $Q=\{(s,e)|s\in S, 0 \leq e \leq ta(s)\}$
			\item $\lambda: S \rightarrow Y$ Ausgabefunktion
		\end{itemize}
		Nachfolgend zu den Zustandsänderungen ist folgendes zu sagen: bei internen Ereignissen möchte das Modell eine Zustandsüberführung zu einem bestimmten Zeitput ($ta(s) \rightarrow tonie$) durchführen (tonie = time of next event), bei externen Ereignissen bekommt das Modelle eine Nachricht und ändert aufgrund der Eingabe seinen Zustand.\\
		Die Atomaren Modelle werden wir später nutzen um einzelne Komponenten in den gekoppelten Modellen zu spezifizieren.
	\subsection{Gekoppelte Modelle}
		Ein gekoppeltes Modell ist eine Dekompostion eines Atomaren Modell. Nachfolgend die formale Definiton: $DEVS = (X,Y,D,\{M_{d}|d \in D\}.EIC,EOC,IC,Select)$ mit:
		\begin{itemize}
			\item $X$ die Eingabemenge
			\item $Y$ die Ausgabemenge
			\item $D$ Menge mit Namen von den Komponenten
			\item $\{M_{d}|d \in D\}$ eine Menge von DEVS-Modellen wobei jedes Modell ein Name $\in D$ besitzt
			\item $EIC$ Menge der externen Eingabekoppelungen (Eingabeports)
			\item $EOC$ Menge der externen Ausgabekoppelungen (Augabeports)
			\item $IC$ Menge der internen Koppelungen (interne Verbindung von Komponenten)
			\item $Select: 2^{D} \rightarrow D$ die Funktion, die bestimmt wenn mehrere Komponenten ein internes Ereignis ausführen wollen, welche Komponente priorisiert wird
		\end{itemize}
	\subsection{Darstellung}
		Eine übliche Darstellungsform sind geschachtelte Rechtecke. Die Koppelungen werden dabei durch gerichtete Pfeile von und zu Dreiecken die auf den Rändern der Rechtecke positioniert sind und nach außen zeigen wenn sie Ausgabeports und nach innen zeigen wenn sie Eingabeports repräsentieren.
		\begin{center}
			\includegraphics[scale=0.6]{images/devs-boxes.jpg}
		\end{center}
		Eine weitere Möglichkeit ist die Darstellung in Form eines hierarchisch aufgebauten Modellbaum. Dabei sind jedoch nicht alle nötigen Informationen bekannt die für die Berechnungen auf dem Modell notwendig sind.
		\begin{center}
			\includegraphics[scale=0.5]{images/devs-baum.jpg}
		\end{center}
		Für die Darstellung eine Ausführungssemantik entsprechende sind noch die Begriffe Koordinatoren und Simulatoren zu klären. In einen Prozessorbaum sind alle gekoppelten5 Modelle Koordinaten und alle atomare Modelle Simulatoren. Diese Unterteilung ist nötig für die Ausführsemantik, welche wir nachträglich noch erkläutern werden.
		\begin{center}
			\includegraphics[scale=0.5]{images/devs-prozessorbaum.jpg}
		\end{center}
	\subsection{Ausführsemantik}
	
\end{document}